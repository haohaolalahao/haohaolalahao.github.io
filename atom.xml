<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://haohaolalahao.github.io</id>
    <title>haohao&apos;s blog</title>
    <updated>2019-10-30T11:07:48.959Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://haohaolalahao.github.io"/>
    <link rel="self" href="https://haohaolalahao.github.io/atom.xml"/>
    <logo>https://haohaolalahao.github.io/images/avatar.png</logo>
    <icon>https://haohaolalahao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, haohao&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[Assembly]]></title>
        <id>https://haohaolalahao.github.io/post/assembly</id>
        <link href="https://haohaolalahao.github.io/post/assembly">
        </link>
        <updated>2019-10-30T10:41:57.000Z</updated>
        <summary type="html"><![CDATA[<p>对于汇编语言基础知识部分的总结</p>
]]></summary>
        <content type="html"><![CDATA[<p>对于汇编语言基础知识部分的总结</p>
<!-- more -->
<h1 id="汇编语言">汇编语言</h1>
<p>格式约定：指令均为小写字母，寄存器均为大写字母</p>
<h2 id="总线">总线</h2>
<ul>
<li>地址总线的宽度决定了CPU的寻址能力</li>
<li>数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量</li>
<li>控制总线的宽度决定了CPU对系统中其他器件的控制能力</li>
</ul>
<h2 id="存储">存储</h2>
<ul>
<li>
<p>地址由0开始索引</p>
</li>
<li>
<p>每一单元的大小为 1Byte = 8 bit</p>
</li>
<li>
<p>常用大小：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>K</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">1KB=2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>M</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">1MB=2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>G</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">1GB=2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li>
<p>8086CPU内存分配基本情况</p>
<figure data-type="image" tabindex="1"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180919200252304.png" alt="image-20180919200252304"></figure>
</li>
</ul>
<h2 id="寄存器">寄存器</h2>
<blockquote>
<p>8086CPU一共有14个寄存器分别为：</p>
<p>AX 、BX 、CX 、DX 、SI 、DI 、SP 、BP 、IP 、CS 、SS 、DS 、ES 、PSW</p>
</blockquote>
<hr>
<h4 id="通用寄存器">通用寄存器</h4>
<blockquote>
<p>AX、BX、CX、DX，为16位寄存器，通常用来存放一般性数据</p>
</blockquote>
<p><strong>Name</strong>:</p>
<p><em>AX：Accumulator Register 累加寄存器</em></p>
<p><em>BX: Base Register 基址寄存器</em></p>
<p><em>CX: Counter Register 计数器</em></p>
<p><em>DX: Data Register 数据寄存器</em></p>
<p><strong>Function</strong></p>
<p>AX ：常用来存储数据</p>
<p>BX： 内存单元的偏移地址，配合DS构成<code>[bx]</code>指令中的内存单元地址</p>
<p>CX： 与loop指令相关，存放循环次数</p>
<p>DX： 数据寄存器，<em>配合AX实现Double 32位数据</em></p>
<p><strong>Special</strong></p>
<p>四种通用寄存器均可拆分为如：XH、XL 高8位和低8位寄存器</p>
<p><strong>Example</strong></p>
<figure data-type="image" tabindex="2"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180919200721352.png" alt="image-20180919200721352"></figure>
<p><strong>Data</strong></p>
<p>字节：<strong>Byte</strong>  8 bit，可放置于8位寄存器中</p>
<p>字：    <strong>Word</strong> 16bit，可放置于16位寄存器中</p>
<figure data-type="image" tabindex="3"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180919201205638.png" alt="image-20180919201205638"></figure>
<p><strong>16进制</strong>：数字后＋H</p>
<p><strong>2进制</strong>：  数字后+B</p>
<p><strong>10进制</strong>：数字后不加后缀</p>
<hr>
<h4 id="段寄存器">段寄存器</h4>
<blockquote>
<p>CS、DS、SS、ES。</p>
</blockquote>
<p><strong>Name</strong></p>
<p><em>CS : code segement</em></p>
<p><em>DS : data segement</em></p>
<p><em>SS : stack segment</em></p>
<p><em>ES : extra segment</em></p>
<p><strong>Function</strong></p>
<p>CS：<em>代码段寄存器</em>   <strong>通常存储代码的初始地址</strong></p>
<p>DS：<em>数据段寄存器</em>  <strong>通常存储内存中的初始地址</strong>  <em>DS 寄存器不能直接被赋以数据值，需要用AX间接来完成</em></p>
<p>SS:  <em>栈段寄存器</em>  <strong>通常存储栈顶元素的初始地址，空元素时指向栈空间最高内存单元的下一个单元</strong></p>
<p><strong>段的概念：物理地址 = 起始地址*16 + 偏移地址</strong></p>
<p>​	其中CS <em>为代码段寄存器</em>，IP <em>为指令指针寄存器</em>， 两者一同为CPU提供指令，CS存储起始地址，IP存储偏移地址，两者得到物理地址查找内存中的代码段指令。</p>
<p><strong>栈的概念</strong>：<strong>段寄存SS和SP用来存放栈顶的初始地址和偏移地址， 二者构成栈顶，帮助完成PUSH、POP指令</strong></p>
<hr>
<h4 id="索引寄存器">索引寄存器</h4>
<blockquote>
<p>SI、DI</p>
</blockquote>
<p><strong>Name</strong></p>
<p><em>SI : source index</em></p>
<p><em>DI: destination index</em></p>
<p><strong>Function</strong></p>
<p>SI和DI是和BX功能相近的寄存器，提供内存便偏移地址，但是不能够分成两个8位寄存器来使用。</p>
<p>以及可用<code>[bx+si] [bx+di] [bx+si+idata] [bx+di+idata]</code>表示内存单元</p>
<hr>
<h4 id="指针寄存器">指针寄存器</h4>
<blockquote>
<p>IP、BP</p>
</blockquote>
<p><strong>只要在[...]中使用寄存器bp，而指令中没有显性的给出段地址，段地址默认在ss中。</strong></p>
<h4 id="标志寄存器">标志寄存器</h4>
<p><strong>Name &amp; Function</strong></p>
<p><em>CF</em> <strong>进位标志</strong>，加法进位或减法借位</p>
<p><em>PF</em>  <strong>奇偶标志</strong>，偶数个1则置1，否则为0</p>
<p><em>AF</em> <strong>辅助进位标志</strong> 如果存在来自最低半字节的进位，就在加法期间存在向第三位进位，或在减法期间向第三位借位。</p>
<p><em>ZF</em> <strong>零标志</strong> 结果为0，则置1</p>
<p><em>SF</em> <strong>符号标志</strong> 表示数字符号，0为正，1为负</p>
<p><em>TF</em> <strong>陷阱标识</strong> 如果设置了该标志，则处理器通过在执行每条指令后产生内部中断进入单步执行模式，如设置断点，<strong>为主动模式</strong></p>
<p><em>IF</em> <strong>中断标志</strong> 外部可屏蔽中断相应；为1允许，为0禁用</p>
<p><em>DF</em> <strong>方向标志</strong> 这由字符串操作指令使用，如果该标志位为0，则从最低地址开始处理字符串到最高地址，即自动递增模式，否则，从最高地址向最低地址处理字符串。</p>
<p><em>OF</em> <strong>溢出标志</strong> 有符号数运算溢出则为1</p>
<hr>
<h2 id="指令">指令</h2>
<h4 id="数据传送指令">数据传送指令：</h4>
<h5 id="通用数据传送指令">通用数据传送指令：</h5>
<blockquote>
<p>mov、push、pop、xchg</p>
</blockquote>
<h6 id="mov">mov</h6>
<p><strong>传送指令:</strong><code>mov DST,SRC</code></p>
<p>执行操作：<code>(DST)&lt;=(SRC)</code></p>
<p><strong>注意</strong></p>
<ul>
<li>DST不能是CS</li>
<li>DST、SRC不能同时为段寄存器</li>
<li>立即数不能直接送段寄存器</li>
<li>DST不能是立即数</li>
<li>DST、SRC不能同时为存储器寻址</li>
</ul>
<h6 id="push">push</h6>
<p><strong>入栈指令：</strong><code>push SRC</code></p>
<p>执行操作：<code>(SP)&lt;=(SP)-2</code></p>
<p>​		  <code>((SP)+1,(SP))&lt;=(SRC)</code></p>
<h6 id="pop">pop</h6>
<p><strong>出栈指令：</strong><code>pop DST</code></p>
<p>执行操作：<code>(DST)&lt;=((SP)+1,(SP))</code></p>
<p>​		  <code>(SP)&lt;=(SP)+2</code></p>
<h6 id="xchg">xchg</h6>
<blockquote>
<p>高级指令，主要操作对象为寻址单元和通用寄存器</p>
</blockquote>
<p><strong>交换指令：</strong><code>xchg opr1 opr2</code></p>
<p>执行操作：<code>(opr1)&lt;=(opr2)</code></p>
<p><strong>注意</strong>：</p>
<ul>
<li><mark>不影响标志位</mark></li>
<li>不允许使用段寄存器</li>
<li>不允许有立即数</li>
</ul>
<h5 id="累加器专用传送指令">累加器专用传送指令</h5>
<blockquote>
<p>in、out、xlat</p>
</blockquote>
<h6 id="xlat"><mark>xlat</mark></h6>
<p><strong>换码指令：</strong><code>xlat</code> 或 <code>xlat opr</code></p>
<p><strong>执行操作：</strong><code>(AL) &lt;= ((BX)+(AL))</code></p>
<p><em>Demo</em></p>
<figure data-type="image" tabindex="4"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180922212830361.png" alt="image-20180922212830361"></figure>
<pre><code>mov bx,offset TABLE  ;(BX) = 0040H
mov al,3
xlat TABLE
</code></pre>
<p><em>offset 取 TABLE 标号处的偏移地址 0040H 赋给 BX，而后 BX 与 AL 内容相加取其内容更新 AL 本身内容</em></p>
<p><strong>注意</strong></p>
<ul>
<li><mark>不影响标志位</mark></li>
<li>字节表格（长度不超过256）</li>
</ul>
<h5 id="地址传送指令">地址传送指令</h5>
<blockquote>
<p>lea、lds、les</p>
</blockquote>
<h6 id="lea">lea</h6>
<p>有效地址送寄存器指令：<code>lea REG,SRC</code></p>
<p>执行操作：<code>(REG)&lt;=SRC</code></p>
<h6 id="lds">lds</h6>
<p>指针送寄存器和DS指令：<code>lds REG SRC</code></p>
<p>执行操作：<code>(REG)&lt;=(SRC)</code></p>
<p>​		 <code>(DS)&lt;=(SRC+2)</code></p>
<p>​		4个相继字节 -&gt; 寄存器（通常是SI）、DS</p>
<h6 id="les">les</h6>
<p>指针送寄存器和ES指令：<code>les REG SRC</code></p>
<p>执行操作：<code>(REG)&lt;=(SRC)</code></p>
<p>​		 <code>(ES)&lt;=(SRC+2)</code></p>
<p>​		4个相继字节 -&gt; 寄存器（通常是SI）、ES</p>
<hr>
<p><em>Demo</em></p>
<figure data-type="image" tabindex="5"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180922220429483.png" alt="image-20180922220429483"></figure>
<pre><code>mov bx,offest TABLE ;(BX)=0040H

lea bx,TABLE  ;(BX)=1000H

lds bx,TABLE  ;(BX)=0040H
			  ;(DS)=3000H

les,bx,TABLE  ;(BX)=0040H
			  ;(ES)=3000H
</code></pre>
<p><strong>注意</strong></p>
<ul>
<li><mark>不影响标志位</mark></li>
<li>REG不能是段寄存器</li>
<li>SRC必须为存储器寻址方式</li>
</ul>
<h5 id="标志寄存器传送指令">标志寄存器传送指令</h5>
<blockquote>
<p>lahf、sahf、pushf、popf</p>
</blockquote>
<p><mark>影响标志位</mark></p>
<h6 id="lahf">lahf</h6>
<p>标志寄存器送 AH 指令：<code>lahf</code></p>
<p>执行操作：<code>(AH)&lt;=(PSW的低字节)</code></p>
<h6 id="sahf">sahf</h6>
<p>AH送标志寄存器指令：<code>sahf</code></p>
<p>执行操作：<code>(PSW的低字节)&lt;=(AH)</code></p>
<h6 id="pushf">pushf</h6>
<p>标志寄存器入栈指令：<code>pushf</code></p>
<p>执行操作：<code>(SP)&lt;= (SP) -2</code></p>
<p>​		<code>((SP)+1,(SP))&lt;=(PSW)</code></p>
<h6 id="poshf">poshf</h6>
<p>标志寄存器出栈指令：<code>popf</code></p>
<p>执行操作：<code>(PSW)&lt;=((SP)+1,(SP))</code></p>
<p>​	       	<code>(SP)&lt;= (SP)+2</code></p>
<p><em>pushf 和 popf为直接访问 PSW 提供了一种方法</em></p>
<h5 id="类型转换指令扩展指令">类型转换指令（扩展指令）</h5>
<blockquote>
<p>cbw、cwd</p>
</blockquote>
<h6 id="cbw">cbw</h6>
<p><code>cbw</code></p>
<p><code>(AL) -&gt; (AX)</code></p>
<p>执行操作：若 (AL) 的最高有效位为0，则 (AH) = 00H</p>
<p>​		  若 (AL) 的最高有效位为1，则 (AH) = 0FFH</p>
<h6 id="cwd">cwd</h6>
<p><code>cwd</code></p>
<p><code>(AX) -&gt; (DX,AX)</code></p>
<p>执行操作：若（AX）的最高有效位为0，则 (DX) = 000H</p>
<p>​		  若（AX）的最高有效位为1，则 (DX) = 0FFFFH</p>
<hr>
<p><strong>注意</strong></p>
<ul>
<li>无操作数指令</li>
<li><strong>隐含对 AL 或 AX 进行<mark>符号拓展</mark></strong></li>
<li><mark>不影响条件标志位</mark></li>
</ul>
<hr>
<h4 id="算术指令">算术指令</h4>
<h5 id="加法指令"><strong>加法指令</strong></h5>
<blockquote>
<p>add、adc、inc</p>
<p>除inc指令不影响CF标志外，均对条件标志位有影响</p>
</blockquote>
<h6 id="add">add</h6>
<p>加法指令：<code>add DST,SRC</code></p>
<p>执行操作：<code>(DST)&lt;=(SRC)+(DST)</code></p>
<h6 id="adc">adc</h6>
<p><strong>带进位加法指令：</strong><code>adc DST,SRC</code></p>
<p>执行操作：<code>(DST) &lt;= (SRC) + (DST) + CF</code>  <strong>包含进位标志寄存器的数值</strong></p>
<h6 id="inc">inc</h6>
<p>加1指令： <code>inc OPR</code></p>
<p>执行操作：<code>(OPR) &lt;= (OPR) + 1</code></p>
<h6 id="注意"><strong>注意</strong></h6>
<p><mark>除 inc 指令不影响CF标志位外，均对条件标志位有影响</mark></p>
<p><strong>加法指令对条件标志位的影响如下：</strong></p>
<figure data-type="image" tabindex="6"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180923195635652.png" alt="image-20180923195635652"></figure>
<p><strong>四种情况：</strong></p>
<figure data-type="image" tabindex="7"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180923195707916.png" alt="image-20180923195707916"></figure>
<hr>
<h5 id="减法指令"><strong>减法指令</strong></h5>
<blockquote>
<p>sub、sbb、dec、neg、cmp</p>
</blockquote>
<h6 id="sub">sub</h6>
<p>减法指令：<code>sub DST,SRC</code></p>
<p>执行操作：<code>(DST) &lt;= (DST)-(SRC)</code></p>
<h6 id="sbb">sbb</h6>
<p><strong>带借位减法指令：</strong><code>sbb DST,SRC</code></p>
<p>执行操作：<code>(DST)&lt;= (DST) - (SRC) - CF</code></p>
<h6 id="dec">dec</h6>
<p>减1指令：<code>dec OPR</code></p>
<p>执行操作:<code>(OPR) &lt;= (OPR) - 1</code></p>
<h6 id="neg">neg</h6>
<p><strong>求补指令：</strong><code>neg OPR</code></p>
<p>执行操作：<code>(OPR) &lt;= -(OPR)</code></p>
<h6 id="cmp">cmp</h6>
<p><strong>比较指令：</strong><code>cmp OPR1,OPR2</code></p>
<p>执行操作：<code>(OPR1) - (OPR2)</code></p>
<p><strong>无符号数的比较</strong></p>
<p><code>cmp AX,BX</code></p>
<blockquote>
<p>标志位： ZF、CF</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">标志位</th>
<th style="text-align:center">情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ZF = 1</td>
<td style="text-align:center">(AX) = (BX)</td>
</tr>
<tr>
<td style="text-align:center">ZF = 0</td>
<td style="text-align:center">(AX) ≠ (BX)</td>
</tr>
<tr>
<td style="text-align:center">CF = 1</td>
<td style="text-align:center">(AX) &lt; (BX)</td>
</tr>
<tr>
<td style="text-align:center">CF = 0</td>
<td style="text-align:center">(AX) ≥ (BX)</td>
</tr>
<tr>
<td style="text-align:center">CF = 0 且 ZF = 0</td>
<td style="text-align:center">(AX) &gt; (BX)</td>
</tr>
<tr>
<td style="text-align:center">CF = 1 或 ZF = 1</td>
<td style="text-align:center">(AX) ≤ (BX)</td>
</tr>
</tbody>
</table>
<p><strong>有符号数的比较</strong></p>
<p><code>cmp AX,DX</code></p>
<blockquote>
<p>标志位：ZF、SF、OF</p>
<p>大于 小于的情况有两种</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">标志位</th>
<th style="text-align:center">情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ZF = 1</td>
<td style="text-align:center">(AX) = (BX)</td>
</tr>
<tr>
<td style="text-align:center">ZF = 0</td>
<td style="text-align:center">(AX) ≠ (BX)</td>
</tr>
<tr>
<td style="text-align:center">SF = 1 且 OF = 0</td>
<td style="text-align:center">(AX) &lt; (BX)</td>
</tr>
<tr>
<td style="text-align:center">SF = 0 且 OF = 1</td>
<td style="text-align:center">(AX) &lt; (BX)</td>
</tr>
<tr>
<td style="text-align:center">SF = 1 且 OF = 1</td>
<td style="text-align:center">(AX) &gt; (BX)</td>
</tr>
<tr>
<td style="text-align:center"><mark>SF = 0 且 OF = 0</mark></td>
<td style="text-align:center"><mark>(AX) ≥ (BX)</mark></td>
</tr>
</tbody>
</table>
<h6 id="注意-2">注意</h6>
<p><mark>除dec指令不影响CF标志外，均对条件标志位有影响</mark></p>
<p><strong>减法指令对条件标志位的影响：</strong></p>
<figure data-type="image" tabindex="8"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180923200728233.png" alt="image-20180923200728233"></figure>
<p><strong>neg指令对CF/OF的影响：</strong></p>
<figure data-type="image" tabindex="9"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180923200829247.png" alt="image-20180923200829247"></figure>
<h5 id="除法指令"><strong>除法指令</strong></h5>
<ul>
<li>
<p>div <strong>无符号除法指令</strong></p>
<ul>
<li>
<p>执行操作：</p>
<ul>
<li>
<p><strong>字节</strong>操作 <code>(AL)&lt;= (AX)/(SRC)</code>的商</p>
<p>​                <code>(AH)&lt;=(AX)/(SRC)</code>的余数</p>
</li>
<li>
<p><strong>字</strong>操作 <code>(AX)&lt;=(DX,AX)/(SRC)</code>的商</p>
<p>​            <code>(DX)&lt;=(DX,AX)/(SRC)</code>的余数</p>
</li>
</ul>
<pre><code>div word ptr es:[0]
;含义 (ax) = [(dx)*10000H + (ax)] / ((es)*16+0)的商
;含义 (dx) = [(dx)*10000H + (ax)] / ((es)*16+0)的余数
div byte ptr [bx+si+8]
;含义 (al) = (ax)/[(ds)*16 + (bx) + (si) + 8]的商
;含义 (ah) = (ax)/[(ds)*16 + (bx) + (si) + 8]的余数
div word ptr [bx+si+8]
;含义 (ax) = [(dx)*10000H + (ax)]dd((ds)*16+(bx)+(si)+8)的商
;含义 (dx) = [(dx)*10000H + (ax)]/((ds)*16+(bx)+(si)+8)的余数
</code></pre>
<ul>
<li><strong>注意</strong>： <strong>32位数地址表示的方式</strong>  <code>[dx]*10000H + (ax)</code></li>
<li>需要分析被除数的大小，分16位或32位情况</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>带符号数除法指令：</strong> idiv</p>
</li>
<li>
<p>注意：</p>
<ul>
<li><mark>对所有条件标志位均无定义</mark></li>
</ul>
</li>
</ul>
<h5 id="乘法指令"><strong>乘法指令</strong></h5>
<ul>
<li>
<p>mul <strong>无符号数乘法指令</strong></p>
<ul>
<li>
<p><strong>执行操作</strong></p>
<ul>
<li>字节操作数<code>(AX) &lt;= (AL)*(SRC)</code> <em>8位乘法，结果16位</em></li>
<li>字操作数<code>(DX,AX) &lt;= (AX)*(SRC)</code> <em>16位乘法，结果32位</em></li>
</ul>
</li>
<li>
<p>格式如下：</p>
<ul>
<li><code>mul reg</code></li>
<li><code>mul 内存单元</code></li>
<li>内存单元可以用不同的寻址方式给出，如：<code>mul byte ptr ds:[0]</code></li>
</ul>
</li>
<li>
<p><strong>demo</strong> 计算100<em>10</em></p>
<pre><code>mov al,100
mov bl,10
mul bl
;结果 (ax) = 1000(03E8H)
</code></pre>
</li>
<li>
<p><strong>demo</strong> 计算100*10000</p>
<p>100小于255，10000大于255，必须做16位乘法</p>
<pre><code>mov ax,100
mov bx,10000
mul bx
;结果 (ax)=4204H, (dx)=00FH (F4240H=1000000)
</code></pre>
</li>
</ul>
</li>
<li>
<p>imul <strong>带符号数乘法指令</strong></p>
<ul>
<li>执行操作：<code>imul SRC</code></li>
</ul>
</li>
<li>
<p><strong>乘法指令对CF/OF的影响</strong></p>
<figure data-type="image" tabindex="10"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180923203431558.png" alt="image-20180923203431558"></figure>
</li>
</ul>
<h5 id="十进制调整指令"><strong>十进制调整指令</strong></h5>
<p><strong>BCD码</strong></p>
<ul>
<li>压缩的BCD码，用4位二进制数表示1位十进制数</li>
<li>非压缩的BCD码，用8位二进制数表示1位十进制数</li>
</ul>
<p><strong>调整原理</strong></p>
<figure data-type="image" tabindex="11"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180923205002920.png" alt="iimage-20180923205002920"></figure>
<figure data-type="image" tabindex="12"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180923205019012.png" alt="image-20180923205019012"></figure>
<h6 id="加法的十进制调整指令-aaa">加法的十进制调整指令 aaa</h6>
<ul>
<li>
<p>aaa <u>非压缩BCD码调整指令</u></p>
<p>本指令对在AL中的由两个未组合的BCD码相加后的结果进行调正，得到一个正确的未组合的BCD码。</p>
<ul>
<li><strong>aaa 指令只影响AF和CF</strong></li>
<li><mark>aaa 指令应紧跟在 add 或 adc 指令之后</mark></li>
</ul>
</li>
<li>
<p>aaa 指令的操作如下</p>
<p>如果 AL 的低四位大于9 或者 AF = 1, 则：</p>
<ul>
<li><code>AL &lt;= (AL) + 6, (AH) &lt;= AH + 1, AF &lt;= 1</code></li>
<li><code>AL &lt;= ((AL) ^ 0FH)</code></li>
<li><code>CF &lt;= AF</code></li>
</ul>
<p>否则</p>
<ul>
<li><code>AL &lt;= (AL)^0FH</code></li>
</ul>
</li>
</ul>
<h6 id="压缩bcd码加法调整指令-daa">压缩BCD码加法调整指令 daa</h6>
<ul>
<li>
<p>两个压缩BCD码相加结果在AL中，通过daa调整得到一个正确的压缩BCD码</p>
</li>
<li>
<p>指令操作：</p>
<ul>
<li>
<p>若 AL 的低4位大于9 或 AF = 1</p>
<p>则 <code>(AL) &lt;= (AL)+6, AF&lt;=1</code></p>
</li>
<li>
<p>若 AL 的高4位大于9 或 CF = 1</p>
<p>则 <code>(AL) &lt;= (AL)+60H, CF &lt;= 1</code></p>
</li>
</ul>
</li>
<li>
<p><strong>除OF外， daa 指令影响所有其他标志</strong></p>
</li>
<li>
<p><mark>daa 指令应紧跟在 add 或 adc 指令之后</mark></p>
</li>
</ul>
<hr>
<h4 id="转移指令">转移指令</h4>
<blockquote>
<p><strong>可以修改ip，或同时修改CS和IP的指令统称为转移指令。</strong></p>
<ul>
<li>只修改ip时，称为段内转移  <em>64k</em></li>
<li>同时修改CS和IP时，称为段间转移  <em>超过64k</em></li>
</ul>
<p><strong>由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移</strong></p>
<ul>
<li>短转移IP的修改范围为-128~127</li>
<li>近转移IP的修改范围为-32768~32767</li>
</ul>
<p>8086CPU的转移指令可以分为以下几类：</p>
<ul>
<li>无条件转移指令（如：jmp）</li>
<li>条件转移指令</li>
<li>循环指令（如：loop）</li>
<li>过程</li>
<li>中断</li>
</ul>
</blockquote>
<h5 id="offest指令">offest指令</h5>
<ul>
<li>offset 取得标号的偏移地址</li>
</ul>
<pre><code>    assume cs:code
    code segment
    	start: mov ax, offset start ;相当于 mov ax,0
    		s: mov ax, offest s     ;相当于 mov ax,3
    code ends
    end start
</code></pre>
<h5 id="jmp指令">jmp指令</h5>
<ul>
<li><strong>jmp</strong> <strong>无条件转移指令，可以只修改IP，也可以同时修改CS和IP</strong>
<ul>
<li>jmp指令需要给出两种信息：
<ul>
<li>转移的目的地址</li>
<li>转移的距离（段间转移、段内短转移、段内近转移)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="依据位移进行转移的-jmp-指令">依据位移进行转移的 jmp 指令</h6>
<ul>
<li>
<p><strong>jmp指令实际工作原理</strong></p>
<ul>
<li>计算预读取指令 **（jmp指令后一条）**到标号的位移</li>
<li>示意图<img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180917205341326.png" alt="image-20180917205341326"></li>
</ul>
</li>
<li>
<p><code>jmp short 标号</code></p>
<ul>
<li>短转移</li>
<li><strong>实际功能为</strong>：<code>（IP） = （Ip） +　８</code>；８位位移范围为*-128~127*补码表示，<strong>位移在编译时计算得出</strong></li>
<li><mark>8位位移 = 标号处的地址-jmp指令后的第一个字节的地址</mark></li>
</ul>
</li>
<li>
<p><code>jmp near ptr 标号</code></p>
<ul>
<li>段内近转移</li>
<li><strong>实际功能为</strong>：<code>（IP） = （Ip） +　16</code>；16位位移范围为*-32768~32767*补码表示，<strong>位移在编译时计算得出</strong></li>
<li><mark>16位位移 = 标号处的地址 - mp指令后的第一个字节的地址</mark></li>
</ul>
</li>
</ul>
<h6 id="转移的目的地址在指令中的-jmp-指令">转移的目的地址在指令中的 jmp 指令</h6>
<ul>
<li><code>jmp far ptr 标号</code>
<ul>
<li>段间转移，又称远转移</li>
<li>同时修改CS和IP，在机器码中指明标号的段地址和偏移地址</li>
</ul>
</li>
</ul>
<h6 id="转移地址在寄存器中的-jmp-指令">转移地址在寄存器中的 jmp 指令</h6>
<ul>
<li><code>jmp 16位 reg</code>
<ul>
<li><mark>(IP) = （16位 reg）</mark></li>
</ul>
</li>
</ul>
<h6 id="转移地址在内存中的-jmp-指令">转移地址在内存中的 jmp 指令</h6>
<ul>
<li>
<p><code>jmp word ptr 内存单元地址（段内转移）</code></p>
<ul>
<li>
<p><mark>从内存单元地址中开始存放着一个字，<strong>是转移的目的偏移地址</strong></mark></p>
</li>
<li>
<p>内存单元地址可用寻址方式的任一格式给出</p>
<pre><code>demo
mov ax,0123H
mov ds:[0],ax
jmp word ptr ds:[0]
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>jmp dword ptr 内存单元地址（段间转移）</code></p>
<ul>
<li>
<p><mark>从内存单元地址处开始存放着两个字，高地址处的字是 <strong>转移的目的段地址</strong>，低地址处的字是 <strong>转移的目的偏移地址</strong></mark></p>
</li>
<li>
<p>(CS) = 内存单元+2 （IP）= 内存单元</p>
</li>
<li>
<pre><code class="language-assembly">demo
mov ax,0123H
mov ds:[0],ax
mov word ptr ds:[2],0
jmp dword ptr ds:[0]
;执行后，CS:IP指向0000:0123
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="jcxz指令">jcxz指令</h5>
<blockquote>
<p><strong>jcxz指令为有条件转移指令</strong>，所有的有条件转移指令均为短转移，对应机器码中包含转移的位移。</p>
</blockquote>
<ul>
<li><code>jcxz 标号（如果（CX）= 0， 转移到标号处执行</code>
<ul>
<li>当(CX) = 0 时，（IP）=(IP) + 8</li>
<li>相当于c语言中的：if ((CX) == 0) jmp short 标号;</li>
</ul>
</li>
</ul>
<h5 id="loop指令">loop指令</h5>
<ul>
<li>
<p><code>loop 标号((CX)=(CX)-1),如果(CX)≠ 0，转移到标号处执行</code></p>
</li>
<li>
<p><strong>所有循环指令均为短转移，对应机器码中包含转移的位移</strong></p>
</li>
<li>
<p>功能：(CX) = (CX) - 1; 如果(CX) ≠ 0，(IP) = (IP) + 8位位移；</p>
</li>
<li>
<p><mark>8位位移 = 标号处的位移 - loop指令后的第一个字节的地址</mark></p>
</li>
<li>
<p>范围：<em>-128~127</em></p>
</li>
<li>
<p>demo</p>
<pre><code class="language-assembly">	move cx,循环次数
 
 s:
  	
  	循环执行的程序段
  	
  	loop s
  	
</code></pre>
</li>
</ul>
<h5 id="ret-和-retf-指令">ret 和 retf 指令</h5>
<ul>
<li>ret指令用栈中的数据，修改IP的内容，从而实现近转移。</li>
<li><code>ret</code>
<ul>
<li>CPU执行 ret 指令时，进行下面两部操作：
<ul>
<li>(IP) = ((SS)*16+(SP))</li>
<li>(SP) = (SP) + 2</li>
</ul>
</li>
<li><strong>相当于进行：</strong>
<ul>
<li><strong>pop IP</strong></li>
</ul>
</li>
</ul>
</li>
<li>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</li>
<li><code>retf</code>
<ul>
<li>CPU执行retf指令时，进行下面四步操作：
<ul>
<li>(IP) = ((SS)*16+(SP))</li>
<li>(SP) = (SP) + 2</li>
<li>(CS) = ((SS)*2+(SP))</li>
<li>(SP) = (SP) + 2</li>
</ul>
</li>
<li><strong>相当于进行：</strong>
<ul>
<li><strong>pop IP</strong></li>
<li><strong>pop CS</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="call指令">call指令</h5>
<blockquote>
<p>CPU执行call指令时，进行两步操作：</p>
<ul>
<li>将当前的IP或CS和IP压入栈中</li>
<li>转移</li>
</ul>
<p><strong>call指令不能实现短转移，除此之外与jmp指令原理相同</strong></p>
<p><mark><strong>有压栈过程</strong></mark></p>
</blockquote>
<h6 id="依据位移进行转移的-call-指令">依据位移进行转移的 call 指令</h6>
<ul>
<li><code>call 标号（将当前的IP压栈后，转到标号处执行指令）</code>
<ul>
<li>CPU执行此种格式的 call 指令时，进行如下的操作
<ul>
<li>(SP) = (SP) - 2</li>
<li>((SS)*16 + (SP)) = (IP)</li>
<li>(IP) = (IP) + 16位位移</li>
</ul>
</li>
<li><strong>相当于进行</strong>
<ul>
<li><strong>push IP</strong></li>
<li><strong>jmp near ptr 标号</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="转移的目的地址在指令中的-call-指令">转移的目的地址在指令中的 call 指令</h6>
<ul>
<li><code>call far ptr 标号</code>
<ul>
<li>CPU执行此种格式的 call 指令时，进行如下的操作
<ul>
<li>(SP) = (SP) - 2</li>
<li>((SS)*16+(SP)) = (CS)</li>
<li>(SP) = (SP) - 2</li>
<li>((SS)*16 + (SP)) = (IP)</li>
<li>(IP) = (IP) + 16位位移</li>
</ul>
</li>
<li><strong>相当于进行</strong>
<ul>
<li><strong>push CS</strong></li>
<li><strong>push IP</strong></li>
<li><strong>jmp far ptr 标号</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="转移地址在寄存器中的-call-指令">转移地址在寄存器中的 call 指令</h6>
<ul>
<li><code>call 16位reg</code>
<ul>
<li>CPU执行此种格式的 call 指令时，进行如下的操作
<ul>
<li>(SP) = (SP) - 2</li>
<li>((SS)*16 + (SP)) = (IP)</li>
<li>(IP) = (16位 reg )</li>
</ul>
</li>
<li><strong>相当于进行</strong>
<ul>
<li><strong>push IP</strong></li>
<li><strong>jmp 16位 reg</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="转移地址在内存中的-call-指令">转移地址在内存中的 call 指令</h6>
<ul>
<li><code>call word ptr 内存单元地址</code>
<ul>
<li><strong>相当于进行</strong>
<ul>
<li><strong>push IP</strong></li>
<li><strong>jmp word ptr 内存单元地址</strong></li>
</ul>
</li>
</ul>
</li>
<li><code>call dword ptr 内存单元地址</code>
<ul>
<li><strong>相当于进行</strong>
<ul>
<li><strong>push CS</strong></li>
<li><strong>push IP</strong></li>
<li><strong>jmp dword prt 内存单元地址</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="call-和-ret-的配合使用">call 和 ret 的配合使用</h5>
<p><strong>demo</strong>：<strong>call 和 ret 配合以实现子程序的机制</strong></p>
<pre><code class="language-assembly">assume cs:code
code segement
start: mov ax,1
	   mov cx,3
	   call s       ;CS:IP指向下一条指令，此时 PUSH 入栈
	   mov bx,ax
	   mov ax,4c00H
	   int 21H
	 s:add ax,ax
	   loop s
	   ret          ;POP IP 出栈 跳转
code ends
end start
</code></pre>
<p><strong>Example</strong> ：<strong>基本框架</strong></p>
<pre><code class="language-assembly">assume cs:code
code segement
main: :
	  :
	  call sub1			;调用子程序sub1  PUSH one
	  :					;POP one 到此处
	  :
	  mov ax,4c00H
	  int 21H
	  
sub1: :					;子程序sub1开始
	  :
	  call sub2			;调用子程序sub2  PUSH two
	  :					;POP two 到此处
	  :
	  ret				;子程序返回      POP one
	  
sub2: :					;子程序sub2开始
	  :
	  :
	  ret				;子程序返回		POP two
code ends
end main
</code></pre>
<hr>
<h4 id="逻辑指令">逻辑指令</h4>
<h5 id="逻辑运算指令">逻辑运算指令</h5>
<ul>
<li>and  按位进行逻辑与运算
<ul>
<li><code>and DST,SRC</code></li>
<li><code>(DST)&lt;=(DST)与(SRC)</code></li>
</ul>
</li>
<li>or     按位进行逻辑或运算
<ul>
<li><code>or DST，SRC</code></li>
<li><code>(DST)&lt;=(DST)或(SRC)</code></li>
</ul>
</li>
<li>xor   按位进行逻辑异或运算
<ul>
<li><code>xor DST,SRC</code></li>
<li><code>(DST)&lt;=(DST)异或(SRC)</code></li>
</ul>
</li>
<li>test 测试指令
<ul>
<li><code>test OPR1,OPR2</code></li>
<li><code>(OPR1)与(OPR2)</code></li>
</ul>
</li>
</ul>
<hr>
<p><strong>以上指令对标志位的影响</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">CF</th>
<th style="text-align:center">OF</th>
<th style="text-align:center">SF</th>
<th style="text-align:center">ZF</th>
<th style="text-align:center">PF</th>
<th style="text-align:center">AF</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">*</td>
<td style="text-align:center">无定义</td>
</tr>
</tbody>
</table>
<p>其中SF、ZF、PF 根据运算结果设置</p>
<hr>
<ul>
<li>not  逻辑非指令
<ul>
<li><code>not OPR</code></li>
<li><code>(OPR) &lt;= 非(OPR)</code></li>
<li><strong>OPR不能为你立即数</strong></li>
<li>非指令不影响标志位</li>
</ul>
</li>
</ul>
<h5 id="移位指令"><strong>移位指令</strong></h5>
<ul>
<li>
<p>逻辑左移 <code>shl OPR,CNT</code></p>
<figure data-type="image" tabindex="13"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180930094553991.png" alt="image-20180930094553991"></figure>
</li>
<li>
<p>逻辑右移 <code>shr OPR,CNT</code></p>
<figure data-type="image" tabindex="14"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180930094653242.png" alt="image-20180930094653242"></figure>
</li>
<li>
<p>算术左移 <code>sal OPR,CNT</code>  <strong>同逻辑左移</strong></p>
</li>
<li>
<p>算术右移 <code>sar OPR,CNT</code></p>
<figure data-type="image" tabindex="15"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180930094818222.png" alt="image-20180930094818222"></figure>
</li>
<li>
<p>循环左移 <code>rol OPR,CNT</code></p>
<figure data-type="image" tabindex="16"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180930095026156.png" alt="image-20180930095026156"></figure>
</li>
<li>
<p>循环右</p>
</li>
<li>
<p>移<code>ror OPR,CNT</code></p>
<figure data-type="image" tabindex="17"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180930095112204.png" alt="image-20180930095112204"></figure>
</li>
<li>
<p>带进位循环左移 <code>rcl OPR,CNT</code></p>
<figure data-type="image" tabindex="18"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180930095150985.png" alt="image-20180930095150985"></figure>
</li>
<li>
<p>带进位循环右移<code>rcr OPR,CNT</code></p>
<figure data-type="image" tabindex="19"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180930095236418.png" alt="image-20180930095236418"></figure>
</li>
</ul>
<hr>
<h6 id="注意-3">注意</h6>
<ul>
<li>
<p>OPR可用除立即数外的任意寻址方式</p>
</li>
<li>
<p><code>CNT = 1, shl OPR,1</code></p>
</li>
<li>
<p><code>CNT ≠ 1, mov CL,CNT shl OPR,CL</code>  <mark>移动数不等于1时，需用寄存器间接传递</mark></p>
</li>
<li>
<p>条件标志位：</p>
<figure data-type="image" tabindex="20"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180930095557935.png" alt="image-20180930095557935"></figure>
</li>
</ul>
<hr>
<h4 id="串处理指令">串处理指令</h4>
<h5 id="设置方向标志指令">设置方向标志指令</h5>
<h6 id="cld">cld</h6>
<p>使得DF = 0 从低位开始，每次操作后SI、DI递增</p>
<h6 id="srd">srd</h6>
<p>使得DF = 1 从高位开始，每次操作后SI、DI递减</p>
<h5 id="串处理指令-2">串处理指令</h5>
<h6 id="movs-movsbmovsw">movs  movsb/movsw</h6>
<p><strong>传送串指令</strong></p>
<p><code>movs DST,SRC</code></p>
<p><code>movsb</code>   <em>字节</em></p>
<p><code>movsw</code>   <em>字</em></p>
<p><strong>执行操作</strong></p>
<p><em>DS 送入 ES</em></p>
<ul>
<li><code>((ES)*16 + (DI)) &lt;= ((DS)*16 + (SI))</code></li>
<li>字节操作：<code>(SI)&lt;=(SI)±1, (DI)&lt;=(DI)±1</code></li>
<li>字操作：<code>(SI)&lt;=(SI)±2,(DI)&lt;=(DI)±2</code></li>
</ul>
<p><strong>传送指令需提供的必要信息</strong></p>
<ol>
<li>传送的原始位置： DS:SI</li>
<li>传送的目的位置： ES:DI</li>
<li>传送的长度： CX</li>
<li>传送的方向： DF</li>
</ol>
<p><strong>Demo</strong></p>
<pre><code class="language-assembly">movs es:byte ptr[DI], DS:[SI]
</code></pre>
<p>**方向标志DF=时用 + ，DF=1时用 - **</p>
<hr>
<h6 id="stos-stosbstosw">stos stosb/stosw</h6>
<p><strong>存入串指令</strong></p>
<p><code>stos DST</code></p>
<p><code>stosb</code> <em>字节</em></p>
<p><code>stosw</code> <em>字</em></p>
<p><strong>执行操作</strong></p>
<ul>
<li>字节操作：<code>((DI))&lt;=(AL),(DI)&lt;=(DI)±1</code></li>
<li>字操作：<code>((DI))&lt;=(AL),(DI)&lt;=(DI)±2</code></li>
</ul>
<hr>
<h6 id="lods-lodsblodsw">lods lodsb/lodsw</h6>
<p><strong>从串取指令</strong></p>
<p><code>lods src</code></p>
<p><code>lodsb</code> <em>字节</em></p>
<p><code>lodsw</code> <em>字</em></p>
<p><strong>执行操作</strong></p>
<ul>
<li>字节操作：<code>((AL))&lt;=(SI),(SI)&lt;=(SI)±1</code></li>
<li>字操作：<code>((AX))&lt;=(SI),(SI)&lt;=(SI)±2</code></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><mark>lods 指令一般不与 rep 联用</mark></li>
<li>源串一般在数据段中（允许使用段跨越前缀来修改），<strong>目的串<mark>必须</mark>在附加段中</strong></li>
<li>不影响条件标志位</li>
</ul>
<hr>
<h6 id="cmps-cmpsbcmpsw">cmps cmpsb/cmpsw</h6>
<p><strong>串比较指令</strong></p>
<p><code>cmps SRC,DST</code></p>
<p><code>cmpsb</code> <em>字节</em></p>
<p><code>cmpsw</code> <em>字</em></p>
<p><strong>执行操作：</strong></p>
<ol>
<li>
<p><code>((SI))-((DI))</code></p>
<p>根据比较结果置条件标志位：相等ZF = 1</p>
<p>​						  不等ZF = 0</p>
</li>
<li>
<p>字节操作：<code>(SI)&lt;=(SI) ± 1, (DI)&lt;=(DI) ± 1</code></p>
<p>​    字操作：<code>(SI)&lt;=(SI) ± 2, (DI)&lt;=(DI) ± 2</code></p>
</li>
</ol>
<hr>
<h6 id="scas">scas</h6>
<p><strong>串扫描指令</strong></p>
<p><code>scas DST</code></p>
<p><code>scasb</code> <em>字节</em></p>
<p><code>scasw</code> <em>字</em></p>
<p><strong>执行操作</strong></p>
<ul>
<li>字节操作：<code>(AL)-((DI)),(DI)&lt;=(DI)±1</code></li>
<li>字操作：<code>(AX)-((DI)),(DI)&lt;=(DI)±2</code></li>
</ul>
<hr>
<h5 id="串重复前缀">串重复前缀</h5>
<h6 id="与-rep-配合工作的-movsstoslods">与 rep 配合工作的 movs/stos/lods</h6>
<p><code>rep movs/stos/lods</code></p>
<p>执行操作：</p>
<ol>
<li>如<code>(cx)=0</code>则退出rep，否则转 2.</li>
<li><code>(CX)&lt;=(CX)-1</code></li>
<li>执行movs/stos/lods</li>
<li>重复1~3</li>
</ol>
<h6 id="rep-movs">rep movs</h6>
<blockquote>
<p>将数据段中的整串数据传送到附加段</p>
<p>源串（数据段）-&gt; 目的串（附加段）</p>
</blockquote>
<p>执行<code>rep movs</code>之前，应先做好：</p>
<ol>
<li>
<p>源串首地址(末地址)  ——&gt; SI</p>
</li>
<li>
<p>目的串首地址(末地址) ——&gt; DI</p>
</li>
<li>
<p>串长度 ——&gt; CX</p>
</li>
<li>
<p>建立方向标志</p>
<p>(cld 使DF=0, std使DF=1)</p>
</li>
</ol>
<figure data-type="image" tabindex="21"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181002162953918.png" alt="image-20181002162953918"></figure>
<h6 id="与reperepz-repnerepnz配合工作的-cmps-和-scas">与repe/repz (repne/repnz)配合工作的 cmps 和 scas</h6>
<p><code>repe/repz cmps/scas</code>或<code>repnz/repnz cmps/scas</code></p>
<p><strong>执行操作</strong></p>
<ol>
<li>如<code>(CX)=0</code> 或 <code>ZF=0 (ZF=1)</code>则退出，否则转2</li>
<li><code>(CX)&lt;=(CX)-1</code></li>
<li>执行 cmps/scas</li>
<li>重复1~3</li>
</ol>
<p><strong>Demo</strong></p>
<figure data-type="image" tabindex="22"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181002212721746.png" alt="image-20181002212721746"></figure>
<hr>
<h4 id="控制转移指令">控制转移指令</h4>
<h5 id="无条件转移指令">无条件转移指令</h5>
<h6 id="jmp">jmp</h6>
<p>段内直接短转移：<code>jmp short OPR</code></p>
<p>​	执行操作：<code>(IP)&lt;=(IP) + 8位位移量</code></p>
<p>段内直接近转移：<code>jmp near ptr OPR</code></p>
<p>​      执行操作：<code>(IP) &lt;= (IP) + 16位位移量</code></p>
<p>段内间接转移：<code>jmp word ptr OPR</code></p>
<p>​      执行操作：<code>(IP) &lt;= (EA)</code></p>
<p>段间直接远转移：<code>jmp far ptr OPR</code></p>
<p>​       执行操作：<code>(IP)&lt;=OPR</code> 段内偏移地址</p>
<p>​			  <code>(CS)&lt;=OPR</code>所在段的段地址</p>
<p>段间间接转移：<code>jmp dword ptr OPR</code></p>
<p>​	执行操作:  <code>(IP)&lt;=(EA)</code></p>
<p>​			<code>(CS)&lt;=(EA+2)</code></p>
<p>​</p>
<hr>
<h5 id="条件转移指令">条件转移指令</h5>
<p><em>只能使用段内直接寻址的8位位移量</em></p>
<blockquote>
<p>jz/jnz、je/jne./、js/jns、jo/jno、</p>
<p>jp/jnp、jb/jnb、jl/jnl、jbe/jnbe、</p>
<p>jle/jnle、jcxz</p>
</blockquote>
<p><strong>英文表示</strong></p>
<p><em>e: equal</em>          <em>等于</em></p>
<p><em>ne: not equeal</em>    <em>不等于</em></p>
<p><em>b: below</em>          <em>小于</em></p>
<p><em>nb: not below</em>     <em>大于等于</em></p>
<p><em>a: above</em>          <em>大于</em></p>
<p><em>na: not above</em>     <em>小于等于</em></p>
<p><em>l: less</em>           <em>小于</em></p>
<p><em>nl: not less</em>      <em>大于等于</em></p>
<p><em>g: great</em>          <em>大于</em></p>
<p><em>ng: not great</em>     <em>小于扥呼吁</em></p>
<hr>
<h6 id="根据单个条件标志的设置情况转移">根据单个条件标志的设置情况转移</h6>
<table>
<thead>
<tr>
<th style="text-align:center">格式</th>
<th style="text-align:center"></th>
<th style="text-align:center">测试条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">jz/je</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">ZF = 1</td>
</tr>
<tr>
<td style="text-align:center">jnz/jne</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">ZF = 0</td>
</tr>
<tr>
<td style="text-align:center">js</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">SF = 1</td>
</tr>
<tr>
<td style="text-align:center">jns</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">SF = 0</td>
</tr>
<tr>
<td style="text-align:center">jo</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">OF = 1</td>
</tr>
<tr>
<td style="text-align:center">jno</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">OF = 0</td>
</tr>
<tr>
<td style="text-align:center">jp</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">PF = 1</td>
</tr>
<tr>
<td style="text-align:center">jnp</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">PF = 0</td>
</tr>
<tr>
<td style="text-align:center">jc</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">CF = 1</td>
</tr>
<tr>
<td style="text-align:center">jnc</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">CF = 0</td>
</tr>
</tbody>
</table>
<hr>
<h6 id="比较两个-无符号数-并根据比较结果转移">比较两个 <strong>无符号数</strong> ，并根据比较结果转移</h6>
<p><strong>cmp 常与以下指令配合使用，表现出来的逻辑含义类似于IF语句</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">格式</th>
<th style="text-align:center">标号</th>
<th style="text-align:center">测试条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">jb/jnae/jc</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">CF = 1</td>
</tr>
<tr>
<td style="text-align:center">.&gt;=</td>
<td style="text-align:center">jnb/jae/jnc</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">CF = 0</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">jna/jbe</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">CF v ZF  = 1</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">ja/jnbe</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">CF v ZF = 0</td>
</tr>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">je</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">ZF = 1</td>
</tr>
<tr>
<td style="text-align:center">≠</td>
<td style="text-align:center">jne</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">ZF ≠ 1</td>
</tr>
</tbody>
</table>
<p><strong>适用于地址或双精度数低位字的比较</strong></p>
<hr>
<h6 id="比较两个-带符号数-并根据比较结果转移">比较两个 <strong>带符号数</strong> ，并根据比较结果转移</h6>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">格式</th>
<th style="text-align:center"></th>
<th style="text-align:center">测试条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">jl/jnge</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">SF ⊕ OF = 1</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">jnl/jge</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">SF ⊕ OF = 0</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">jle/jng</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">(SF ⊕ OF)∨ZF = 1</td>
</tr>
<tr>
<td style="text-align:center">.&gt;=</td>
<td style="text-align:center">jnle/jg</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">(SF ⊕ OF)∨ZF = 0</td>
</tr>
</tbody>
</table>
<p><strong>适用于带符号数的比较</strong></p>
<hr>
<h6 id="测试cx的值为0则转移">测试CX的值，为0则转移</h6>
<table>
<thead>
<tr>
<th style="text-align:center">格式</th>
<th style="text-align:center"></th>
<th style="text-align:center">测试条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">jcxz</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">（CX) = 0</td>
</tr>
</tbody>
</table>
<hr>
<h5 id="循环指令">循环指令</h5>
<p><strong><mark>注意</mark></strong></p>
<ul>
<li>CX中存放循环次数</li>
<li>只能使用段内直接寻址的8位位移量</li>
</ul>
<p><code>loop</code></p>
<p><code>loopz / loope</code></p>
<p><code>loopnz / loopne</code></p>
<p><strong>执行步骤</strong></p>
<ol>
<li><code>(CX)&lt;=(CX)-1</code></li>
<li>是否满足 <strong>测试条件</strong>：满足则<code>(IP)&lt;=(IP)+8位位移量</code>，实现循环；不满足则IP不变，退出循环。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">格式</th>
<th style="text-align:center"></th>
<th style="text-align:center">测试条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">loop</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">(CX) ≠ 0</td>
</tr>
<tr>
<td style="text-align:center">loopz/loope</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">ZF = 1 且 (CX) ≠ 0</td>
</tr>
<tr>
<td style="text-align:center">loopnz/loopne</td>
<td style="text-align:center">OPR</td>
<td style="text-align:center">ZF = 0 且 (CX) ≠ 0</td>
</tr>
</tbody>
</table>
<p><strong>等价写法</strong></p>
<figure data-type="image" tabindex="23"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181002223522749.png" alt="image-20181002223522749"></figure>
<hr>
<h5 id="子程序调用和返回指令">子程序调用和返回指令</h5>
<figure data-type="image" tabindex="24"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181002223555561.png" alt="image-20181002223555561"></figure>
<p>见转移指令 call 和 ret 指令</p>
<hr>
<h5 id="中断与中断返回指令">中断与中断返回指令</h5>
<p><strong>中断向量</strong></p>
<figure data-type="image" tabindex="25"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181008191717736.png" alt="image-20181008191717736"></figure>
<h6 id="int">int</h6>
<p><code>int type</code></p>
<p>执行操作：</p>
<pre><code class="language-assembly">(SP) &lt;= (SP)-2
((SP)+1,(SP)) &lt;= (PSW)
(SP) &lt;= (SP)-2
((SP)+1,(SP)) &lt;= (CS)
(SP) &lt;= (SP)-2
((SP)+1,(SP)) &lt;= (IP)
(IP) &lt;= (type*4)
(CS) &lt;= (type*4+2)
</code></pre>
<h6 id="iret">iret</h6>
<p><code>iret</code></p>
<p>执行操作：</p>
<pre><code class="language-assembly">(IP) &lt;= ((SP)+1,(SP)) 
(SP) &lt;= (SP)+2
(CS) &lt;= ((SP)+1,(SP)) 
(SP) &lt;= (SP)+2
(PSW) &lt;= ((SP)+1,(SP)) 
(SP) &lt;= (SP)+2
</code></pre>
<hr>
<h4 id="处理机控制与杂项操作指令">处理机控制与杂项操作指令</h4>
<h5 id="标志处理指令">标志处理指令</h5>
<p><strong>标志位赋值</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Name</th>
<th style="text-align:center">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">clc</td>
<td style="text-align:center">CF &lt;= 0</td>
</tr>
<tr>
<td style="text-align:center">stc</td>
<td style="text-align:center">CF &lt;= 1</td>
</tr>
<tr>
<td style="text-align:center">cld</td>
<td style="text-align:center">DF &lt;= 0</td>
</tr>
<tr>
<td style="text-align:center">std</td>
<td style="text-align:center">DF &lt;= 1</td>
</tr>
<tr>
<td style="text-align:center">cli</td>
<td style="text-align:center">IF &lt;= 0</td>
</tr>
<tr>
<td style="text-align:center">sti</td>
<td style="text-align:center">IF &lt;= 1</td>
</tr>
</tbody>
</table>
<p><mark>注意</mark>：只影响本指令指定的标志</p>
<h5 id="其他处理机控制与杂项操作指令">其他处理机控制与杂项操作指令</h5>
<table>
<thead>
<tr>
<th style="text-align:center">Name</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">nop</td>
<td style="text-align:left">无操作（机器码占一个字节）</td>
</tr>
<tr>
<td style="text-align:center">hlt</td>
<td style="text-align:left">暂停（等待一次外中断，之后继续执行程序）</td>
</tr>
<tr>
<td style="text-align:center">wait</td>
<td style="text-align:left">等待（等待外中断，之后任继续等待）</td>
</tr>
<tr>
<td style="text-align:center">esc</td>
<td style="text-align:left">换码</td>
</tr>
<tr>
<td style="text-align:center">lock</td>
<td style="text-align:left">封锁（维持总线的锁存信号，直到其后的指令执行完）</td>
</tr>
</tbody>
</table>
<p><mark>注意</mark>：不影响条件标志</p>
<hr>
<h4 id="定义数据">定义数据</h4>
<ul>
<li>dw <strong>define word</strong> 定义字型数据，大小为16个字节</li>
<li>db 定义字符类型数据，编码为ASCII， 格式：<code>db 'HelloWorld'</code></li>
<li>dd <strong>double word</strong> 定义两个字型数据，大小为两个字</li>
<li>word ptr **指明为字型数据 **
<ul>
<li><em>demo：</em>  mov word ptr ds:[0],1</li>
</ul>
</li>
<li>byte ptr  <strong>指明为字节型数据</strong>
<ul>
<li><em>demo:</em>     mov byte ptr ds:[0], 1</li>
</ul>
</li>
<li><strong>dup</strong> 配合 dw db dd 使用， 进行数据重复
<ul>
<li><code>db 重复的次数 dup(重复的字节型数据)</code></li>
<li><code>dw 重复的次数 dup(重复的字型数据)</code></li>
<li><code>dd 重复的次数 dup(重复的双子型数据)</code></li>
<li>在定义stack段或者data段 时候比较好用</li>
</ul>
</li>
</ul>
<h4 id="栈相关指令">栈相关指令</h4>
<blockquote>
<p><strong>单位为字， 只进行字操作</strong></p>
</blockquote>
<ul>
<li>push 入栈  <em>内存地址从高向低变化</em>
<ul>
<li>push 实现步骤：
<ul>
<li>SP = SP - 2，栈顶指针上移，SS:SP指向新栈顶</li>
<li>将ax中的内容送入SS:SP指向的内存单元</li>
<li><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180918200218685.png" alt="image-20180918200218685"></li>
</ul>
</li>
</ul>
</li>
<li>pop 出栈
<ul>
<li>pop 实现步骤：
<ul>
<li>将SS:SP指向的内存单元送入ax中</li>
<li>SP = SP + 2，栈顶指针上移，SS:SP指向新栈顶</li>
<li><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180918200644024.png" alt="image-20180918200644024"></li>
</ul>
</li>
</ul>
</li>
<li><strong>起始栈顶指针的指向：栈段可用空间+1（最高位）</strong></li>
</ul>
<hr>
<h4 id="bx-指令">[bx] 指令</h4>
<ul>
<li><code>[bx]</code> 表示内存单元地址，其内存单元的<strong>偏移地址寄存在bx寄存器中，段地址寄存在ds中</strong></li>
</ul>
<p>约定<code>( )</code>内中的内容为物理地址，表示物理地址的内容</p>
<p>则<code>[bx]=((bs)*16+(bx))</code> 表示一个指定的内存单元</p>
<ul>
<li>
<p>可用<code>[bx+idata]=((bs)*16+(bx)+idata)</code>灵活表示一个指定的内存单元</p>
<p>此指令等价于<code>[bx+200] == 200[bx] == [bx].200</code></p>
<p><strong>相当于数组</strong></p>
</li>
</ul>
<hr>
<h2 id="寻址方式">寻址方式</h2>
<blockquote>
<p>处理器根据指令中给出的地址信息来寻找有效地址的方式</p>
</blockquote>
<p><em>所用指令：</em></p>
<pre><code class="language-assembly">mov dtc src
</code></pre>
<hr>
<h3 id="与数据有关的寻址方式">与数据有关的寻址方式：</h3>
<hr>
<h4 id="立即寻址方式操作数在指令中给出">立即寻址方式——操作数在指令中给出</h4>
<p><em>Demo</em></p>
<pre><code class="language-assembly">mov al,5
mov ax,3064H
mov al,'A'
</code></pre>
<p><em>注意</em></p>
<ul>
<li>只能用于SRC字段</li>
<li>SRC和DST的字长一致</li>
</ul>
<hr>
<h4 id="寄存器寻址方式操作数在指定的寄存器中">寄存器寻址方式——操作数在指定的寄存器中</h4>
<p><em>Demo</em></p>
<pre><code class="language-assembly">mov ax,bh
mov al,bh
</code></pre>
<p><em>注意</em></p>
<ul>
<li>SRC和DST的字长一致</li>
<li><strong>CS不能使用MOV指令改变</strong></li>
</ul>
<hr>
<h4 id="直接寻址方式有效地址ea由指令直接给出">直接寻址方式——有效地址EA由指令直接给出</h4>
<p><em>Demo</em></p>
<pre><code class="language-assembly">mov ax, [2000H]
</code></pre>
<p><em>注意</em></p>
<ul>
<li>
<p><strong>隐含的段为数据段DS</strong></p>
</li>
<li>
<p><strong>可使用<mark>段跨越前缀</mark></strong> 如：<code>MOV AX, ES:[2000H]</code></p>
</li>
<li>
<p><strong>操作数地址可由变量（符号地址）表示</strong></p>
<pre><code class="language-assembly">value db 10
mov ax, word ptr value
</code></pre>
</li>
</ul>
<hr>
<h4 id="寄存器间接寻址ea在基址寄存器bxbp或变址寄存器sidi中">寄存器间接寻址——EA在基址寄存器（bx/bp）或变址寄存器（si/di）中</h4>
<p><em>Demo</em></p>
<pre><code class="language-assembly">mov ax,[bx]   		;PA = (SS)*16+(BX)
mov ax,es:[bx]		;PA = (ES)*16+(BX)
mov ax,[bp]			;PA = (SS)*16+(BP) BP默认段寄存器为SS
</code></pre>
<p><em>注意</em></p>
<ul>
<li>不允许使用AX、CX、DX存放EA</li>
<li>SRC和DST的字长一致</li>
<li>适于数组、字符串、表格的处理</li>
</ul>
<hr>
<h4 id="寄存器相对寻址方式">寄存器相对寻址方式</h4>
<figure data-type="image" tabindex="28"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180920204252944.png" alt="image-20180920204252944"></figure>
<p><em>Demo</em></p>
<pre><code class="language-assembly">mov ax,idata[si]
mov ax,[si+idata]
</code></pre>
<p><em>注意</em></p>
<ul>
<li>适于数组、字符串、表格的处理</li>
</ul>
<hr>
<h4 id="基址变址寻址方式">基址变址寻址方式</h4>
<figure data-type="image" tabindex="29"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180920204455892.png" alt="image-20180920204455892"></figure>
<p><em>Demo</em></p>
<pre><code class="language-assembly">mov ax,[bx][di]
mov ax,[bx+di]
mov ax,es:[bx][si]
</code></pre>
<ul>
<li>适于数组、字符串、表格的处理</li>
<li><strong>必须是一个基址寄存器和一个变址寄存器的组合</strong></li>
</ul>
<hr>
<h4 id="相对基址变址寻址方式">相对基址变址寻址方式</h4>
<figure data-type="image" tabindex="30"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20180920204714162.png" alt="image-20180920204714162"></figure>
<p><em>Demo</em></p>
<pre><code class="language-assembly">mov ax,idata[bx][si]
mov ax,idata[bx+si]
mov ax,[bx+si+idata]
mov ax,[bx].idata[si]
</code></pre>
<hr>
<h3 id="与转移地址有关的寻址方式">与转移地址有关的寻址方式</h3>
<p>详见 jmp 指令和 call 指令</p>
<h3 id="总结">总结</h3>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">常用格式举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[idata]</td>
<td style="text-align:center">直接寻址</td>
<td style="text-align:center">[idata]</td>
</tr>
<tr>
<td style="text-align:center">[bx]</td>
<td style="text-align:center"><strong>寄存器间接寻址</strong></td>
<td style="text-align:center">[bx]</td>
</tr>
<tr>
<td style="text-align:center">[si]</td>
<td style="text-align:center"><strong>寄存器间接寻址</strong></td>
<td style="text-align:center">[bx]</td>
</tr>
<tr>
<td style="text-align:center">[di]</td>
<td style="text-align:center"><strong>寄存器间接寻址</strong></td>
<td style="text-align:center">[bx]</td>
</tr>
<tr>
<td style="text-align:center">[bp]</td>
<td style="text-align:center"><strong>寄存器间接寻址</strong></td>
<td style="text-align:center">[bx]</td>
</tr>
<tr>
<td style="text-align:center">[bx+idata]</td>
<td style="text-align:center">寄存器相对寻址</td>
<td style="text-align:center">用于结构体:[bx].idata</td>
</tr>
<tr>
<td style="text-align:center">[si+idata]</td>
<td style="text-align:center">寄存器相对寻址</td>
<td style="text-align:center">用于数组：idata[si]，idata[di]</td>
</tr>
<tr>
<td style="text-align:center">[di+idata]</td>
<td style="text-align:center">寄存器相对寻址</td>
<td style="text-align:center">用于二维数组：<code>[bx][ idata]</code></td>
</tr>
<tr>
<td style="text-align:center">[bp+idata]</td>
<td style="text-align:center">寄存器相对寻址</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[bx+si]</td>
<td style="text-align:center"><strong>基址变址寻址</strong></td>
<td style="text-align:center">用于二维数组：<code>[bx][si]</code></td>
</tr>
<tr>
<td style="text-align:center">[bx+di]</td>
<td style="text-align:center"><strong>基址变址寻址</strong></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[bp+si]</td>
<td style="text-align:center"><strong>基址变址寻址</strong></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[bp+di]</td>
<td style="text-align:center"><strong>基址变址寻址</strong></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">[bx+si+idata]</td>
<td style="text-align:center">相对基址变址寻址</td>
<td style="text-align:center">用于表格中的数组项：</td>
</tr>
<tr>
<td style="text-align:center">[bx+di+idata]</td>
<td style="text-align:center">相对基址变址寻址</td>
<td style="text-align:center">[bx].idata[si]</td>
</tr>
<tr>
<td style="text-align:center">[bp+si+idata]</td>
<td style="text-align:center">相对基址变址寻址</td>
<td style="text-align:center">用于二维数组：</td>
</tr>
<tr>
<td style="text-align:center">[bp+di+idata]</td>
<td style="text-align:center">相对基址变址寻址</td>
<td style="text-align:center"><code>idata[bx][si]</code></td>
</tr>
</tbody>
</table>
<h2 id="内中断">内中断</h2>
<h3 id="内中断的产生">内中断的产生</h3>
<p>四种中断信息：</p>
<ol>
<li>除法错误，比如，执行div指令产生的除法溢出</li>
<li>单步执行</li>
<li>执行 into 指令</li>
<li>执行 int 指令</li>
</ol>
<p><strong>中断信息必须包含识别来源的编码，称为中断类型码，大小：1个字节</strong></p>
<p>四种中断信息的中断类型码如下：</p>
<ol>
<li>除法错误：0</li>
<li>单步执行：1</li>
<li>执行 into 指令：4</li>
<li>执行 int 指令，该指令的格式为int n，指令中的 n 为字节型立即数，是 提供给 CPU 的中断类型码</li>
</ol>
<h3 id="中断处理程序">中断处理程序</h3>
<blockquote>
<p>CPU 在收到中断信息后，需要对中断信息进行处理，用来处理中断信息的程序被称为中断处理程序</p>
</blockquote>
<p><strong>重要问题</strong>：</p>
<p>CPU 在收到中断信息后，如果根据中断信息确定其处理程序的入口，即将CS:IP指向程序第一条指令的地址</p>
<p><strong>根据中断类型码，获取中断处理程序的第一条指令的地址</strong></p>
<h3 id="中断向量表">中断向量表</h3>
<p>中断向量：中断处理程序的入口地址</p>
<p>中断向量表：中断处理程序入口地址的列表</p>
<p><strong>8086PC 机，从内存0000：0000 到 0000：03FF的 1024 个单元中存放着中断向量表</strong></p>
<p><strong>一个表项占据 4 个字节，高地址存放段地址（CS），低地址存放偏移地址（IP）</strong></p>
<h3 id="中断过程">中断过程</h3>
<p>下面是 8086 CPU 在收到中断信息后，所引发的中断过程</p>
<ol>
<li>（从中断信息中）取得中断类型码；</li>
<li><strong>标志寄存器的值入栈</strong>（因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中）；</li>
<li>设置标志寄存器的<strong>第八位 TF 和 第九位 IF 的值为 0</strong> ；</li>
<li>CS 的内容入栈；</li>
<li>IP 的内容入栈；</li>
<li>从内存地址为 中断类型码×4 和 中断类型码×4 + 2 的两个字单元中读取中断处理程序的入口地址设置IP和CS</li>
</ol>
<p>更简洁的描述中断过程，如下：</p>
<ol>
<li>取得中断类型码 N</li>
<li>pushf</li>
<li>TF=0，IF=0</li>
<li>push CS</li>
<li>push IP</li>
<li>(IP) = (N*4),(CS)=(N*4+2)</li>
</ol>
<h3 id="中断处理程序和-iret-指令">中断处理程序和 iret 指令</h3>
<p>两个要求：</p>
<ul>
<li><strong>中断处理程序必须一直存储在内存某段空间之中</strong></li>
<li><strong>中断处理程序的入口地址，必须存储在对于的中断向量表表项之中</strong></li>
</ul>
<p>编写常规步骤：</p>
<ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复用到的寄存器</li>
<li>用 iret 指令返回</li>
</ol>
<p>iret 指令的功能：</p>
<pre><code class="language-assembly">pop IP
pop CS
popf
</code></pre>
<h3 id="demo-除法错误中断的处理">Demo 除法错误中断的处理</h3>
<p><strong>目的</strong>:</p>
<p>重新编写一个 0 号中断处理程序，功能是在屏幕中间显示“overflow!”，然后返回到操作系统</p>
<p><strong>条件</strong>：</p>
<p>从0000：0020 至 0000：02FF的256个字节的空间所对应的中断向量表项都是空的，操作系统和其他应用程序都不占用，此处存放中断处理程序 <em>do0</em></p>
<p><strong>程序1.1 大体框架</strong></p>
<pre><code class="language-assembly">assume cs:code

code segment

start: do0 安装程序
	   设置中断向量表
	   
	   mov ax,4c00H
	   int 21h
	   
do0:   显示字符串&quot;overflow！&quot;
	   mov ax,4c00h
	   int 21h
	   
code ends
ene start

</code></pre>
<p><strong>程序1.2 do0 安装 伪代码</strong></p>
<pre><code class="language-assembly">assume cs:code

code segment

start: 设置 ES:DI 指向目的地址
	   设置 DS:SI 指向源地址
	   设置 CX 为传输长度
	   设置传输方向为正
	   rep movsb
	   
	   设置中断向量表
	   
	   mov ax,4c00H
	   int 21h
	   
do0:   显示字符串&quot;overflow！&quot;
	   mov ax,4c00h
	   int 21h
	   
code ends
ene start
</code></pre>
<p><strong>程序1.2 do0 安装</strong></p>
<pre><code class="language-assembly">assume cs:code

code segment


start: mov AX,CS
	   mov DS,AX	
	   mov SI,offset do0      					;设置 DS:DI 指向目的地址
	   
	   mov AX,0
	   mov ES,AX
	   mov di,200H			   					;设置 ES:SI 指向源地址
	   
	   mov cx,offset do0end-offset do0		    ;设置 CX 为传输长度
	   
	   cld                    					;设置传输方向为正
	   
	   rep movsb
	   
	   设置中断向量表
	   
	   mov ax,4c00H
	   int 21h
	   
do0:   显示字符串&quot;overflow！&quot;
	   mov ax,4c00h
	   int 21h
	   
do0end: nop

code ends
ene start
</code></pre>
<p><strong>程序1.3 do0</strong></p>
<pre><code class="language-assembly">assume cs:code

code segment

start: mov AX,CS
	   mov DS,AX	
	   mov SI,offset do0      					;设置 DS:DI 指向目的地址
	   
	   mov AX,0
	   mov ES,AX
	   mov Di,200H			   					;设置 ES:SI 指向源地址
	   
	   mov CX,offset do0end-offset do0		    ;设置 CX 为传输长度
	   
	   cld                    					;设置传输方向为正
	   
	   rep movsb
	   
	   设置中断向量表
	   
	   mov AX,4c00H
	   int 21h
	   
do0:   jmp short do0start
	   db &quot;overflow!&quot;
	   
	   
do0start: mov AX,CS
		  mov DS, AX
		  mov SI,202h							;设置DS:SI指向字符串
		  
		  mov AX,0b800h
		  mov ES,AX
		  mov DI,12*160+36*2					;设置ES:DI指向显存空间中的中间位置
		  
		  mov CX,9								;设置CX为字符串长度
	      
	      
	    S:mov AL,[SI]
		  mov ES:[DI],AL
		  inc si
		  add di,2
		  loop s
		  
		  mov ax,4c00h
	      int 21h
	   
do0end: nop

code ends
ene start
</code></pre>
<p><strong>程序1.4 设置中断向量</strong></p>
<pre><code class="language-assembly">assume cs:code

code segment

start: mov AX,CS
	   mov DS,AX	
	   mov SI,offset do0      			;设置 DS:DI 指向目的地址
	   
	   mov AX,0
	   mov ES,AX
	   mov Di,200H			   			;设置 ES:SI 指向源地址
	   
	   mov CX,offset do0end-offset do0  ;设置 CX 为传输长度
	   
	   cld                    			;设置传输方向为正
	   
	   rep movsb
	   
	   mov AX,0
	   mov ES,AX
	   mov word ptr ES:[0*4],200h
	   mov word ptr ES:[0*4+2],0
	   
	   mov AX,4c00H
	   int 21h
	   
	   
do0:   jmp short do0start
	   db &quot;overflow!&quot;
       
 
do0start: mov AX,CS
		  mov DS, AX
		  mov SI,202h			;设置DS:SI指向字符串
		  
		  mov AX,0b800h
		  mov ES,AX
		  mov DI,12*160+36*2	;设置ES:DI指向显存空间中的中间位置
		  
		  mov CX,9				;设置CX为字符串长度
	      
	
	    S:mov AL,[SI]
		  mov ES:[DI],AL
		  inc si
		  add di,2
		  loop s
		  
		  mov ax,4c00h
	      int 21h
	   
do0end: nop

code ends
ene start
</code></pre>
<h2 id="汇编语言程序">汇编语言程序</h2>
<h3 id="定义一个段">定义一个段</h3>
<ul>
<li>
<p><code>segment</code> 和<code>ends</code>是一对成对使用的伪指令。</p>
</li>
<li>
<p><code>segment</code>说明一个段的开始，<code>ends</code>说明一个段的结束</p>
</li>
<li>
<p>一个段必须有一个名称来标识，使用格式为</p>
<pre><code class="language-assembly">name segment
name ends
</code></pre>
</li>
</ul>
<h3 id="寄存器与段的关联假设">寄存器与段的关联假设</h3>
<ul>
<li><code>assume</code> 含义为“假设”</li>
<li><code>assume</code>假设某一<strong>段寄存器</strong>和程序中的某一个用 <code>segement…ends</code>定义的段<strong>相关联</strong></li>
</ul>
<h3 id="程序入口和结束标记">程序入口和结束标记</h3>
<ul>
<li>
<p><code>end [label]</code></p>
<p><code>[label]</code>是程序的入口标记</p>
</li>
<li>
<p><code>end</code>是汇编程序的结束标记，汇编器在汇编汇编程序的过程中，如果碰到了end，就结束对源程序的汇编。</p>
</li>
</ul>
<h3 id="标号">标号</h3>
<p><strong>一个标号指代了一个地址</strong></p>
<h3 id="程序返回">程序返回</h3>
<p>应该在程序的末尾添加返回的程序段</p>
<pre><code class="language-assembly">mov AX,4c00h
int 21h
</code></pre>
<h2 id="伪操作伪指令">伪操作（伪指令）</h2>
<blockquote>
<p>​	是汇编程序对源程序进行汇编时处理的操作，完成处理器选择、存储模式定义、数据定义、存储器分配、指示程序开始结束等功能。</p>
</blockquote>
<h3 id="处理器选择伪操作">处理器选择伪操作</h3>
<p>​	不同处理器选择不同的伪操作指令系统</p>
<h3 id="段定义伪操作">段定义伪操作：</h3>
<h4 id="完整的段定义伪操作">完整的段定义伪操作</h4>
<figure data-type="image" tabindex="31"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011201943231.png" alt="image-20181011201943231"></figure>
<h4 id="汇编源程序的退出方式">汇编源程序的退出方式</h4>
<figure data-type="image" tabindex="32"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011202049696.png" alt="image-20181011202049696"></figure>
<h4 id="带堆栈段的汇编程序">带堆栈段的汇编程序</h4>
<figure data-type="image" tabindex="33"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011202221491.png" alt="image-20181011202221491"></figure>
<h4 id="完整段定义的格式">完整段定义的格式：</h4>
<p>段名 	SEGMENT 【定位类型】【组合类型】【使用类型】【类别】</p>
<p>​		…………......</p>
<p>​		…………......</p>
<p>​		…………......</p>
<p>段名	ENDS</p>
<ul>
<li>
<p>定位类型 <em>align_type</em></p>
<p>PARA BYTE WORD DWORD PAGE</p>
</li>
<li>
<p>组合类型 <em>combine_type</em></p>
<p>PRIVATE	PUBLIC COMMON STACK AT EXP</p>
</li>
<li>
<p>使用类型 <em>use_type</em></p>
<p>USE16 USE32</p>
</li>
</ul>
<h4 id="存储模式与简化段定义伪操作">存储模式与简化段定义伪操作</h4>
<ol>
<li>
<p>MODEL 伪操作</p>
<ul>
<li>
<p>.MODEL 存储模式 【语言类型】【操作系统类型】【堆栈选项】</p>
</li>
<li>
<p><strong>存储模式</strong>： tiny small medium compact large huge flat</p>
</li>
</ul>
<figure data-type="image" tabindex="34"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011205202241.png" alt="image-20181011205202241"></figure>
</li>
<li>
<p>简化的段定义伪操作</p>
<figure data-type="image" tabindex="35"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011205217498.png" alt="image-20181011205217498"></figure>
</li>
</ol>
<h4 id="段组定义伪操作">段组定义伪操作</h4>
<figure data-type="image" tabindex="36"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011205251597.png" alt="image-20181011205251597"></figure>
<h3 id="数据定义及存储器分配伪操作">数据定义及存储器分配伪操作</h3>
<p>【变量】<strong>助记符</strong> 操作数 【，操作数，……..】 【注释】</p>
<ul>
<li>助记符： DB　DW  DD DF  DQ  DT</li>
</ul>
<h3 id="表达式赋值伪操作">表达式赋值伪操作</h3>
<p>​								表达式名		 <strong>EQU</strong> 	表达式</p>
<figure data-type="image" tabindex="37"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011211625429.png" alt="image-20181011211625429"></figure>
<p>​								<strong>“ = ”</strong> 伪操作允许重复定义</p>
<figure data-type="image" tabindex="38"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011211700821.png" alt="image-20181011211700821"></figure>
<h3 id="地址计数器与对准伪操作">地址计数器与对准伪操作</h3>
<ul>
<li>
<p>地址计数器<code>$</code> :<mark>保存当前正在汇编的指令的地址</mark></p>
</li>
<li>
<p><code>ORG $+8</code>      跳过8个字节的存储区</p>
</li>
<li>
<p><code>JNE $+6</code>      转向地址是<code>JNE</code>的首地址+6</p>
</li>
<li>
<p><code>$</code> 用在伪操作的参数字段：<strong>表示地址计数器的当前值</strong></p>
</li>
<li>
<p>Demo</p>
<pre><code class="language-assembly">ARRAY DW 1,2,$+4,3,4,$+4
</code></pre>
<figure data-type="image" tabindex="39"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011212141042.png" alt="image-20181011212141042"></figure>
</li>
<li>
<p><code>ORG</code> 跳字节</p>
<figure data-type="image" tabindex="40"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011212220051.png" alt="image-20181011212220051"></figure>
</li>
<li>
<p><code>EVEN</code> 使下一地址从偶地址开始</p>
<figure data-type="image" tabindex="41"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011212354242.png" alt="image-20181011212354242"></figure>
</li>
</ul>
<h3 id="基数控制伪操作">基数控制伪操作</h3>
<p>.RADIX  表达式  ；规定无标记数的基数</p>
<figure data-type="image" tabindex="42"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011212540401.png" alt="image-20181011212540401"></figure>
<h2 id="汇编语言格式">汇编语言格式</h2>
<h3 id="算术操作符">算术操作符</h3>
<blockquote>
<p>+、-、*、/、mod</p>
</blockquote>
<p><strong>Demo</strong></p>
<figure data-type="image" tabindex="43"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011212743098.png" alt="image-20181011212743098"></figure>
<h3 id="逻辑和移位操作符">逻辑和移位操作符</h3>
<blockquote>
<p>AND、OR、XOR、NOT、SHL、SHR</p>
</blockquote>
<p><strong>Demo</strong></p>
<figure data-type="image" tabindex="44"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011212855716.png" alt="image-20181011212855716"></figure>
<h3 id="关系操作符">关系操作符</h3>
<blockquote>
<p>EQ、NE、LT、LE、GT、GE</p>
</blockquote>
<p><strong>结算结果为逻辑值</strong>： 真 0FFFFh 假 0000h</p>
<p><strong>Demo</strong></p>
<figure data-type="image" tabindex="45"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011213103417.png" alt="image-20181011213103417"></figure>
<h3 id="数值回送操作符">数值回送操作符</h3>
<blockquote>
<p>OFFSET、SEG、TYPE、LENGTH、SIZE</p>
</blockquote>
<ul>
<li>
<p>OFFSET /  SEG   变量/标号</p>
<ul>
<li>功能：回送变量或标号的偏移地址/段地址</li>
</ul>
</li>
<li>
<p>TYPE     变量/标号/常数</p>
<p>​	DB DW DD DF DQ DT NEAR FAR 常数</p>
<p>​	 1     2     4    6    8    20   -1       -2    0</p>
</li>
<li>
<p>LENGTH 变量</p>
<ul>
<li>功能： 回送用<strong>DUP</strong>定义的变量的单元数，其他情况回送1</li>
</ul>
</li>
<li>
<p>SIZE 变量</p>
<ul>
<li>功能：LENGTH*TYPE</li>
</ul>
</li>
<li>
<p>Demo</p>
<figure data-type="image" tabindex="46"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011214051679.png" alt="image-20181011214051679"></figure>
</li>
</ul>
<h3 id="属性操作符">属性操作符</h3>
<blockquote>
<p>PTR、段操作符、SHORT、THIS、HIGH、LOW、HIGHWORD、LOWWORD</p>
</blockquote>
<p><strong>Demo</strong></p>
<figure data-type="image" tabindex="47"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011214233173.png" alt="image-20181011214233173"></figure>
<h3 id="dos-功能调用">DOS 功能调用</h3>
<ul>
<li>
<p>键盘功能调用</p>
<ul>
<li>
<p>单字符输入</p>
<figure data-type="image" tabindex="48"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011214412891.png" alt="image-20181011214412891"></figure>
</li>
<li>
<p>字符串输入</p>
<figure data-type="image" tabindex="49"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011214424637.png" alt="image-20181011214424637"></figure>
</li>
</ul>
</li>
<li>
<p>显示功能调用</p>
<ul>
<li>
<p>显示单个字符</p>
<figure data-type="image" tabindex="50"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011214452676.png" alt="image-20181011214452676"></figure>
</li>
<li>
<p>显示字符串</p>
<figure data-type="image" tabindex="51"><img src="file:///Users/wanghao/Blog/source/_posts/Assembly/image-20181011214508080.png" alt="image-20181011214508080"></figure>
</li>
</ul>
</li>
</ul>
<h2 id="debug">Debug</h2>
<h3 id="常用debug功能">常用Debug功能</h3>
<h4 id="用-debug-的-r-命令查看-改变cpu寄存器的内容">用 Debug 的 R 命令<strong>查看、改变</strong>CPU寄存器的内容</h4>
<p><code>R</code></p>
<ul>
<li>显示所有寄存器中的内容</li>
</ul>
<p><code>R 寄存器名</code></p>
<ul>
<li>显示指定寄存器的内容，可修改</li>
</ul>
<h4 id="用-debug-的-d-命令查看内存中的内容">用 Debug 的 D 命令查看内存中的内容</h4>
<p><code>D [起始位置]段地址：偏移地址</code></p>
<ul>
<li>显示从起始位置起的128个字节的内容</li>
</ul>
<p><code>D 起始位置 结束位置</code></p>
<ul>
<li>显示从起始位置到结束位置的内容</li>
</ul>
<p><code>D 起始位置 L 长度</code></p>
<ul>
<li>显示从起始位置开始到指定长度的内容</li>
</ul>
<h4 id="用-debug-的-e-命令改写内存中的内容">用 Debug 的 E 命令改写内存中的内容</h4>
<p><code>E 起始地址 字节值表</code></p>
<ul>
<li>连续修改内容为 字节值表，16bit</li>
</ul>
<p><code>E 起始地址</code></p>
<ul>
<li>按空格后以 <strong>提问的方式</strong> 每一个内存单元进行修改</li>
</ul>
<h4 id="用-debug-的-u-命令将内存中的机器指令翻译成汇编指令">用 Debug 的 U 命令将内存中的机器指令翻译成汇编指令</h4>
<p><code>U 起始地址</code></p>
<ul>
<li>反汇编</li>
</ul>
<p><code>U 地址范围</code></p>
<ul>
<li>反汇编</li>
</ul>
<h4 id="用-debug-的-t-命令执行一条机器指令">用 Debug 的 T 命令执行一条机器指令</h4>
<p><code>T=[地址]</code></p>
<ul>
<li>执行一条语句 显示寄存器内容与下一条指令</li>
</ul>
<p><code>T=[地址][x]</code></p>
<ul>
<li>跟踪 x 条指令</li>
</ul>
<h4 id="用-debug-的-a-命令以汇编指令的格式在内存中写入一条机器指令">用 Debug 的 A 命令以汇编指令的格式在内存中写入一条机器指令</h4>
<p><code>A 起始地址</code></p>
<ul>
<li>写入汇编指令</li>
</ul>
<h4 id="用-debug-的-g-命令实行断点操作">用 Debug 的 G 命令实行断点操作</h4>
<p><code>G=[起始地址][断点地址]</code></p>
<ul>
<li>从起始地址开始执行到断点地址，如果不设置断点地址，则程序一直执行到终止指令才停止</li>
</ul>
<h4 id="用-debug-的-p-命令执行-loop-循环一次可以直接执行完成">用 Debug 的 P 命令执行 LOOP 循环，一次可以直接执行完成</h4>
<ul>
<li>同 T 指令，但不会跟踪进入子程序或软中断</li>
</ul>
<h3 id="用-debug-的-q-命令执行退出操作">用 Debug 的 q 命令执行退出操作</h3>
<p><code>q</code></p>
<ul>
<li>退出Debug</li>
</ul>
<h3 id="标志寄存器在debug中的表示">标志寄存器在Debug中的表示</h3>
<p><strong>Debug对已知位的表示</strong></p>
<p>表示顺序：</p>
<p>缺少 IF TF</p>
<p>OF DF 	SF ZF 	PF CF</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th style="text-align:center">值为1的标记</th>
<th style="text-align:center">值为0的标记</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OF</td>
<td style="text-align:center">OV</td>
<td style="text-align:center">NV</td>
</tr>
<tr>
<td style="text-align:center">SF</td>
<td style="text-align:center">NG</td>
<td style="text-align:center">PL</td>
</tr>
<tr>
<td style="text-align:center">ZF</td>
<td style="text-align:center">ZR</td>
<td style="text-align:center">NZ</td>
</tr>
<tr>
<td style="text-align:center">PF</td>
<td style="text-align:center">PE</td>
<td style="text-align:center">PO</td>
</tr>
<tr>
<td style="text-align:center">CF</td>
<td style="text-align:center">CY</td>
<td style="text-align:center">NC</td>
</tr>
<tr>
<td style="text-align:center">DF</td>
<td style="text-align:center">DN</td>
<td style="text-align:center">UP</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="注意-4">注意</h2>
<ul>
<li><strong>1字(word) = 2字节(Byte) = 16位(bit)</strong></li>
<li><strong>masm 在编译时候会将[0]解释为数值，需要将其转化为ds:[0]的形式才表示地址！！！</strong>  <em>或者采用[bx]的指令，但此时需要对bx寄存器进行赋值，较为麻烦</em></li>
</ul>
<hr>
<h2 id="demo">demo</h2>
<p>标准格式</p>
<p>注意 程序最后要加</p>
<pre><code class="language-assembly">mov ax,4c00h
int 21h
</code></pre>
<p>其目的是为了将CPU的执行权转交给command控制台</p>
<ul>
<li>数据、栈、代码在一个段内</li>
</ul>
<pre><code class="language-assembly">assmue cs:code

code segment
		:
		:
	&lt; data &gt;		;存放数据、栈
		:	
		:
start:				;提供程序执行入口(初始指令)
		:
		:
	&lt; code &gt;		;存放代码
		:
		:

	mov ax,4c00h
	int 21h
code ends
end start
</code></pre>
<ul>
<li>数据、栈、代码在不同段内</li>
</ul>
<pre><code class="language-assembly">assume cs:code,ds:data,ss:stack

data segment:
		:
		:
	&lt; data &gt;
		:
		:
data ends

stack segment:
		:
		:
	&lt; stack &gt;
		:
		:
stack ends

code segment:
start:
	move ax,stack		;调用  stack 段地址
	move ax,data		;调用  code  段地址
		:
		:
	&lt; code &gt;
		:
		:
	move ax,4c00h
	int 21h
code ends
end start 

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://haohaolalahao.github.io/post/guan-yu</id>
        <link href="https://haohaolalahao.github.io/post/guan-yu">
        </link>
        <updated>2019-10-29T10:56:10.000Z</updated>
        <content type="html"><![CDATA[<p>Hello World</p>
<!-- more -->]]></content>
    </entry>
</feed>